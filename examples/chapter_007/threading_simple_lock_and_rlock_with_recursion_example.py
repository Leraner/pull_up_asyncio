from threading import Thread, Lock, RLock


# С такой блокировкой наша программа зависает.
# Потому что мы вошли первый раз в блокировку, а дальше вызвали функцию рекурсивно не выходя из блокировки.
# Из-за этого следующий вызов функции ожидает, когда блокировка снимется, но она никогда не снимется, потому что
# мы не вышли из блокировки до вызова рекурсии (* - там где не вышли)
list_lock = Lock()

# Для того чтобы избавиться от этой ошибки, нужно использовать реентерабельные блокировки.
# То есть один и тот же поток может входить в свою блокировку. Чтобы использовать реентерабельную блокировку,
# нужно вместо Lock использовать RLock

list_lock = RLock()

# Теперь код будет работать правильно, и один поток сможет захватывать блокировки несколько раз.
# При каждом захвате блокировки потоком, захватившим ее впервые, счетчик увеличивается на 1,
# а при каждом освобождении счетчик уменьшается. Когда счетчик обратится в 0,
# блокировка освобождается и ее могут захватить другие потоки.

def sum_list(int_list: list[int]) -> int:
    print("Ожидание блокировки")
    # !!!!!!
    with list_lock:
        print("Блокировка захвачена")
        if len(int_list) == 0:
            print("Суммирование завершено")
            return 0
        else:
            head, *tail = int_list
            print("Суммируется только остаток списка.")
            # *
            return head + sum_list(tail)


thread = Thread(target=sum_list, args=([1, 2, 3, 4],))
thread.start()
thread.join()
